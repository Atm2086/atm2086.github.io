---
title: 聊天室改写
top: false
cover: false
toc: true
mathjax: true
date: 2025-11-10 10:06:58
password:
summary:
tags:
categories:
---

先粗浅补一个聊天室的作业，之后有机会专门研究下高并发的实现

# 聊天室项目改写

参考 https://github.com/yuesong-feng/30dayMakeCppServer# 高并发服务器

将原pthreads结构的服务器改为epoll线程池结构

## 原聊天室

功能使用：
    client读client.conf配置，在chat.log里记录当前聊天室自己这端能看到的信息
    server那边读配置文件只有port，然后终端里会显示所有人发了什么，会显示有谁已经上线

    （需要新增的：得在客户端里加上能看到的，不知道行不行，不行算了，或者给私聊建个新的配置文件）

具体实现：

- Server文件夹：
    - `server.c`：核心服务端逻辑。读取 server.conf 监听端口，接收客户端登录并维护 struct User 数组；为每个客户端创建线程处理消息，支持广播、私聊和在线人数查询。
    - `server.conf`：服务端配置（目前只指定 SERVER_PORT）。
    - `G`：服务端的编译脚本，命令为 gcc server.c ../common/common.c ../common/tcp_server.c -o server -lpthread。
    
- CLient文件夹：
    - `client.c`：主程序，读取 client.conf 配置，连接服务器并发送登录消息；fork 后子进程负责读取输入并发送消息，父进程重定向输出到日志文件并处理群聊/私聊/通知显示。
    - `client.conf`：客户端配置文件，包含服务器 IP/端口、当前用户名、日志文件路径。
    - `chat.log`：运行时写入的聊天记录（由父进程 freopen() 重定向生成）。
    - `G`：简单编译脚本，实际是 gcc client.c ../common/common.c ../common/tcp_client.c -o client -pthread。

- Commen文件夹：
    - `head.h`：统一引入 stdio.h、sys/socket.h、pthread.h 等标准库，供其余头文件共享。
    - `common.h` & `common.c`：封装通用工具函数。get_value() 读取配置文件键值；make_nonblock/make_block 族函数通过 fcntl/ioctl 切换描述符阻塞模式，并暴露全局缓冲 conf_ans。
    - `chatroom.h`：定义聊天室协议数据结构 struct Msg、struct RecvMsg，以及 chat_send()/chat_recv() 发送接收包装，集中双方通用的消息格式常量（如 MAX_CLIENT）。
    - `tcp_client.h/.c`：客户端侧 socket 帮助函数，socket_connect() 根据 IP/端口创建 TCP 连接并处理失败输出。
    - `tcp_server.h/.c`：服务端监听封装，socket_create() 创建监听 fd，配置 SO_LINGER、SO_REUSEADDR 后 bind/listen。
    - `color.h`：终端 ANSI 颜色宏，给客户端/服务端打印加颜色。

### 具体的实现逻辑，哪里要改

server.cpp

client.cpp

## 原高并发

分析一下暴露的可用的接口，在哪里能对client或者server功能进行重写，流程图怎么画，主要是线程池的范围

暴露的可用的接口：

- Socket / InetAddress：构造、析构：自动创建/关闭 TCP 套接字。
    - bind(InetAddress*)、listen()、accept(InetAddress*)：服务端监听。
    - connect(InetAddress*)：客户端连接。
    - setnonblocking()：设置非阻塞。
    - getFd()：获取底层 fd。
- InetAddress：提供 setInetAddr()、getAddr()、getIp()、getPort() 管理地址。
    - Epoll
    - poll(int timeout=-1)：等待事件，返回活跃 Channel* 列表。
    - updateChannel(Channel*)、deleteChannel(Channel*)：注册或移除事件。
- Channel：绑定事件循环与 fd。
    - enableRead()、useET()：关注读事件/ET 模式。
    -setReadCallback(std::function<void()>)（还有 setReadCallback 以外可扩展 setWrite）。
    - getter：getFd()、getEvents()、setReady()、getInEpoll() 等。
- EventLoop
    - loop()：事件主循环。
    - updateChannel(Channel*)：转调 Epoll。
    - addThread(std::function<void()>) 暂未实现，但可扩展。
- Acceptor：构造时绑定监听、注册读回调。
    - setNewConnectionCallback(std::function<void(Socket*)>)。
    内部 acceptConnection()，一旦有新连接自动调用回调。
- Connection
    - 封装单个客户端连接：在所属 EventLoop 上注册 ET 读事件。
    - setDeleteConnectionCallback(std::function<void(int)>)：断开时通知 Server。
    - echo(int sockfd)：默认的读写回调（可改成自定义处理）。
    - send(int sockfd)：将 readBuffer 内容写回。
- Buffer
    - append()、c_str()、size()、clear()、getline()、setBuf()：字符缓冲管理。
- ThreadPool
    - 构造/析构管理工作线程。
    - add(F&&, Args&&...)：提交任务，返回 std::future。
- util
    - errif(bool, const char*)：错误处理辅助。


### 具体的实现逻辑

Server.cpp用了哪些接口：
  EventLoop *loop = new EventLoop();
  Server *server = new Server(loop);
  loop->loop();
  
- `Server` 内部：
  - 构造 `Acceptor`，注册 `setNewConnectionCallback`。
  - 创建 `ThreadPool`，为每个线程分配一个新的 `EventLoop`（子 reactor），通过线程池运行 `EventLoop::loop()`。
  - `newConnection(Socket*)`：为新 fd 创建 `Connection`，绑定断开回调。

- `Acceptor`：
  - 使用 `Socket` 监听 `127.0.0.1:1234`。
  - 创建 `Channel`，`enableRead()`，设置回调为 `acceptConnection()`。
  - 每次 `acceptConnection()` 新建 `Socket`，调用 `setnonblocking()`，然后执行 `newConnectionCallback`。

- `Connection`：
  - 在指定 `EventLoop` 上建 `Channel`，`enableRead()` + `useET()`。
  - 设置读回调为 `echo()`，在其中循环 `read()`，使用 `Buffer` 累积消息，并调用 `send()` 回射。
  - 当 `read()` 返回 0 或出错时调用 `deleteConnectionCallback`。

## day12 自带 `client.cpp` 的接口使用

- 创建 `Socket`，用 `InetAddress("127.0.0.1", 1234)` 调 `connect()`。
- 通过 `Buffer` 管理输入输出。循环：
  - `sendBuffer->getline()` 读标准输入；
  - `write(sockfd, sendBuffer->c_str(), sendBuffer->size())`（直接调用系统调用）；
  - 重复 `read()`、`append()` 到 `readBuffer`，直到收到同样长度的数据，输出 `readBuffer->c_str()`；
  - `readBuffer->clear()`。

客户端主要使用了 `Socket`、`InetAddress`、`Buffer` 以及系统 `read/write`，没有触碰 `EventLoop`、`Channel` 等高级抽象。

这些组件可以组合使用：`Acceptor`/`Connection`/`Server`/`EventLoop`/`ThreadPool` 提供了一个基于 epoll + Reactor 的并发骨架；`Buffer`、`Socket`、`util` 等可供客户端或服务器其他模块复用。你可以替换 `Connection::echo()` 为自定义消息处理逻辑，也可以扩展 `Server` 来维护聊天室状态。

### 具体改法

buffer的封装可能要多加一个flag，然后通过flag来判断，然后我需要让client程序有一个自己可选的名字之类的参数

我试试在底层buffer情况下用chatroom封装一下这个buffer来制作chatroom的buffer规矩



### cmake的重新编译
